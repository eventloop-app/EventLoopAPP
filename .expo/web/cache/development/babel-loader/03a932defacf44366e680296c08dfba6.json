{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildCodeAsync = buildCodeAsync;\nexports.deriveChallengeAsync = deriveChallengeAsync;\nexports.generateHexStringAsync = generateHexStringAsync;\nexports.generateRandom = generateRandom;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar Crypto = _interopRequireWildcard(require(\"expo-crypto\"));\n\nvar Random = _interopRequireWildcard(require(\"expo-random\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input) {\n  var output = input;\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n  var bytes = Random.getRandomBytes(input.length);\n\n  for (var i = 0; i < bytes.length; i++) {\n    input[i] = bytes[i];\n  }\n\n  return output;\n}\n\nfunction convertBufferToString(buffer) {\n  var state = [];\n\n  for (var i = 0; i < buffer.byteLength; i += 1) {\n    var index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64) {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction generateRandom(size) {\n  var buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\n\nfunction deriveChallengeAsync(_x) {\n  return _deriveChallengeAsync.apply(this, arguments);\n}\n\nfunction _deriveChallengeAsync() {\n  _deriveChallengeAsync = (0, _asyncToGenerator2.default)(function* (code) {\n    (0, _invariant.default)(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n    var buffer = yield Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n      encoding: Crypto.CryptoEncoding.BASE64\n    });\n    return convertToUrlSafeString(buffer);\n  });\n  return _deriveChallengeAsync.apply(this, arguments);\n}\n\nfunction buildCodeAsync() {\n  return _buildCodeAsync.apply(this, arguments);\n}\n\nfunction _buildCodeAsync() {\n  _buildCodeAsync = (0, _asyncToGenerator2.default)(function* () {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n    var codeVerifier = generateRandom(size);\n    var codeChallenge = yield deriveChallengeAsync(codeVerifier);\n    return {\n      codeVerifier: codeVerifier,\n      codeChallenge: codeChallenge\n    };\n  });\n  return _buildCodeAsync.apply(this, arguments);\n}\n\nfunction generateHexStringAsync(_x2) {\n  return _generateHexStringAsync.apply(this, arguments);\n}\n\nfunction _generateHexStringAsync() {\n  _generateHexStringAsync = (0, _asyncToGenerator2.default)(function* (size) {\n    var value = generateRandom(size);\n    var buffer = yield Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n      encoding: Crypto.CryptoEncoding.HEX\n    });\n    return convertToUrlSafeString(buffer);\n  });\n  return _generateHexStringAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/PKCE.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AACA;;AACA;;;;;;AAEA,IAAM,OAAO,GAAG,gEAAhB;;AAEA,SAAS,eAAT,CAAyB,KAAzB,EAA0C;EACxC,IAAM,MAAM,GAAG,KAAf;EAEA,IAAI,KAAK,CAAC,UAAN,KAAqB,KAAK,CAAC,MAA/B,EAAuC,KAAK,GAAG,IAAI,UAAJ,CAAe,KAAK,CAAC,MAArB,CAAR;EAEvC,IAAM,KAAK,GAAG,MAAM,CAAC,cAAP,CAAsB,KAAK,CAAC,MAA5B,CAAd;;EAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC;IAAuC,KAAK,CAAC,CAAD,CAAL,GAAW,KAAK,CAAC,CAAD,CAAhB;EAAvC;;EAEA,OAAO,MAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,MAA/B,EAAiD;EAC/C,IAAM,KAAK,GAAa,EAAxB;;EACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,UAA3B,EAAuC,CAAC,IAAI,CAA5C,EAA+C;IAC7C,IAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAAN,GAAY,OAAO,CAAC,MAAlC;IACA,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,KAAD,CAAlB;EACD;;EACD,OAAO,KAAK,CAAC,IAAN,CAAW,EAAX,CAAP;AACD;;AAED,SAAS,sBAAT,CAAgC,GAAhC,EAA2C;EACzC,OAAO,GAAG,CAAC,OAAJ,CAAY,KAAZ,EAAmB,GAAnB,EAAwB,OAAxB,CAAgC,KAAhC,EAAuC,GAAvC,EAA4C,OAA5C,CAAoD,IAApD,EAA0D,EAA1D,CAAP;AACD;;AAEK,SAAU,cAAV,CAAyB,IAAzB,EAAqC;EACzC,IAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,IAAf,CAAf;EACA,eAAe,CAAC,MAAD,CAAf;EACA,OAAO,qBAAqB,CAAC,MAAD,CAA5B;AACD;;SAMqB,oB;;;;;0DAAf,WAAoC,IAApC,EAAgD;IAErD,IAAA,kBAAA,EAAU,IAAI,CAAC,MAAL,GAAc,EAAd,IAAoB,IAAI,CAAC,MAAL,GAAc,GAA5C,EAAiD,+BAAjD;IAEA,IAAM,MAAM,SAAS,MAAM,CAAC,iBAAP,CAAyB,MAAM,CAAC,qBAAP,CAA6B,MAAtD,EAA8D,IAA9D,EAAoE;MACvF,QAAQ,EAAE,MAAM,CAAC,cAAP,CAAsB;IADuD,CAApE,CAArB;IAGA,OAAO,sBAAsB,CAAC,MAAD,CAA7B;EACD,C;;;;SAEqB,c;;;;;oDAAf,aACa;IAAA,IAAlB,IAAkB,uEAAH,GAAG;IAGlB,IAAM,YAAY,GAAG,cAAc,CAAC,IAAD,CAAnC;IACA,IAAM,aAAa,SAAS,oBAAoB,CAAC,YAAD,CAAhD;IAEA,OAAO;MAAE,YAAY,EAAZ,YAAF;MAAgB,aAAa,EAAb;IAAhB,CAAP;EACD,C;;;;SAKqB,sB;;;;;4DAAf,WAAsC,IAAtC,EAAkD;IACvD,IAAM,KAAK,GAAG,cAAc,CAAC,IAAD,CAA5B;IACA,IAAM,MAAM,SAAS,MAAM,CAAC,iBAAP,CAAyB,MAAM,CAAC,qBAAP,CAA6B,MAAtD,EAA8D,KAA9D,EAAqE;MACxF,QAAQ,EAAE,MAAM,CAAC,cAAP,CAAsB;IADwD,CAArE,CAArB;IAGA,OAAO,sBAAsB,CAAC,MAAD,CAA7B;EACD,C","sourcesContent":["import * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input: Uint8Array): Uint8Array {\n  const output = input;\n  // Get access to the underlying raw bytes\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n\n  const bytes = Random.getRandomBytes(input.length);\n\n  for (let i = 0; i < bytes.length; i++) input[i] = bytes[i];\n\n  return output;\n}\n\nfunction convertBufferToString(buffer: Uint8Array): string {\n  const state: string[] = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    const index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64: string): string {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandom(size: number): string {\n  const buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\n\n/**\n * Proof key for Code Exchange by OAuth Public Clients (RFC 7636), Section 4.1\n * [Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1)\n */\nexport async function deriveChallengeAsync(code: string): Promise<string> {\n  // 43 is the minimum, and 128 is the maximum.\n  invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n    encoding: Crypto.CryptoEncoding.BASE64,\n  });\n  return convertToUrlSafeString(buffer);\n}\n\nexport async function buildCodeAsync(\n  size: number = 128\n): Promise<{ codeChallenge: string; codeVerifier: string }> {\n  // This method needs to be resolved like all other native methods.\n  const codeVerifier = generateRandom(size);\n  const codeChallenge = await deriveChallengeAsync(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Digest a random string with hex encoding, useful for creating `nonce`s.\n */\nexport async function generateHexStringAsync(size: number): Promise<string> {\n  const value = generateRandom(size);\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n    encoding: Crypto.CryptoEncoding.HEX,\n  });\n  return convertToUrlSafeString(buffer);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}