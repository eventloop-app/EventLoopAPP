{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GestureDetector = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _gesture2 = require(\"./gesture\");\n\nvar _reanimatedWrapper = require(\"./reanimatedWrapper\");\n\nvar _handlersRegistry = require(\"../handlersRegistry\");\n\nvar _RNGestureHandlerModule = _interopRequireDefault(require(\"../../RNGestureHandlerModule\"));\n\nvar _gestureHandlerCommon = require(\"../gestureHandlerCommon\");\n\nvar _gestureStateManager = require(\"./gestureStateManager\");\n\nvar _FlingGestureHandler = require(\"../FlingGestureHandler\");\n\nvar _ForceTouchGestureHandler = require(\"../ForceTouchGestureHandler\");\n\nvar _LongPressGestureHandler = require(\"../LongPressGestureHandler\");\n\nvar _PanGestureHandler = require(\"../PanGestureHandler\");\n\nvar _TapGestureHandler = require(\"../TapGestureHandler\");\n\nvar _State = require(\"../../State\");\n\nvar _EventType = require(\"../../EventType\");\n\nvar _reactNative = require(\"react-native\");\n\nvar _eventReceiver = require(\"./eventReceiver\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar _Reanimated$default$c, _Reanimated$default;\n\nvar ALLOWED_PROPS = [].concat((0, _toConsumableArray2.default)(_gestureHandlerCommon.baseGestureHandlerWithMonitorProps), (0, _toConsumableArray2.default)(_TapGestureHandler.tapGestureHandlerProps), (0, _toConsumableArray2.default)(_PanGestureHandler.panGestureHandlerProps), (0, _toConsumableArray2.default)(_PanGestureHandler.panGestureHandlerCustomNativeProps), (0, _toConsumableArray2.default)(_LongPressGestureHandler.longPressGestureHandlerProps), (0, _toConsumableArray2.default)(_ForceTouchGestureHandler.forceTouchGestureHandlerProps), (0, _toConsumableArray2.default)(_FlingGestureHandler.flingGestureHandlerProps));\n\nfunction convertToHandlerTag(ref) {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof _gesture2.BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    var _ref$current$handlerT, _ref$current;\n\n    return (_ref$current$handlerT = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.handlerTag) !== null && _ref$current$handlerT !== void 0 ? _ref$current$handlerT : -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup) {\n  var _interactionGroup$map, _interactionGroup$map2;\n\n  return (_interactionGroup$map = interactionGroup === null || interactionGroup === void 0 ? void 0 : (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) === null || _interactionGroup$map2 === void 0 ? void 0 : _interactionGroup$map2.filter(function (tag) {\n    return tag > 0;\n  })) !== null && _interactionGroup$map !== void 0 ? _interactionGroup$map : [];\n}\n\nfunction dropHandlers(preparedGesture) {\n  for (var handler of preparedGesture.config) {\n    _RNGestureHandlerModule.default.dropGestureHandler(handler.handlerTag);\n\n    (0, _handlersRegistry.unregisterHandler)(handler.handlerTag);\n  }\n}\n\nfunction attachHandlers(_ref) {\n  var preparedGesture = _ref.preparedGesture,\n      gestureConfig = _ref.gestureConfig,\n      gesture = _ref.gesture,\n      viewTag = _ref.viewTag,\n      useAnimated = _ref.useAnimated,\n      webEventHandlersRef = _ref.webEventHandlersRef;\n\n  if (!preparedGesture.firstExecution) {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  setImmediate(function () {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n  });\n\n  var _loop = function _loop(handler) {\n    _RNGestureHandlerModule.default.createGestureHandler(handler.handlerName, handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS));\n\n    (0, _handlersRegistry.registerHandler)(handler.handlerTag, handler);\n    setImmediate(function () {\n      var requireToFail = [];\n\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      var simultaneousWith = [];\n\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);\n      }\n\n      _RNGestureHandlerModule.default.updateGestureHandler(handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n    });\n  };\n\n  for (var handler of gesture) {\n    _loop(handler);\n  }\n\n  preparedGesture.config = gesture;\n\n  for (var _gesture of preparedGesture.config) {\n    if (_reactNative.Platform.OS === 'web') {\n      _RNGestureHandlerModule.default.attachGestureHandler(_gesture.handlerTag, viewTag, !useAnimated, webEventHandlersRef);\n    } else {\n      _RNGestureHandlerModule.default.attachGestureHandler(_gesture.handlerTag, viewTag, !useAnimated);\n    }\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = gesture.map(function (g) {\n      return g.handlers;\n    });\n  }\n}\n\nfunction updateHandlers(preparedGesture, gestureConfig, gesture) {\n  gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n\n  for (var i = 0; i < gesture.length; i++) {\n    var handler = preparedGesture.config[i];\n\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  setImmediate(function () {\n    for (var _i = 0; _i < gesture.length; _i++) {\n      var _handler = preparedGesture.config[_i];\n      _handler.config = gesture[_i].config;\n      _handler.handlers = gesture[_i].handlers;\n      var requireToFail = extractValidHandlerTags(_handler.config.requireToFail);\n      var simultaneousWith = extractValidHandlerTags(_handler.config.simultaneousWith);\n\n      _RNGestureHandlerModule.default.updateGestureHandler(_handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(_handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n\n      (0, _handlersRegistry.registerHandler)(_handler.handlerTag, _handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = preparedGesture.config.map(function (g) {\n        return g.handlers;\n      });\n    }\n  });\n}\n\nfunction needsToReattach(preparedGesture, gesture) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n\n  for (var i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(preparedGesture, needsRebuild) {\n  if (!_reanimatedWrapper.Reanimated) {\n    return;\n  }\n\n  var isStateChangeEvent = function () {\n    var _f = function _f(event) {\n      return event.oldState != null;\n    };\n\n    _f._closure = {};\n    _f.asString = \"function isStateChangeEvent(event){return event.oldState!=null;}\";\n    _f.__workletHash = 13883357260557;\n    _f.__location = \"C:\\\\Users\\\\APIWATSRINUKUL\\\\Desktop\\\\EventLoopAPP\\\\node_modules\\\\react-native-gesture-handler\\\\lib\\\\module\\\\handlers\\\\gestures\\\\GestureDetector.js (165:2)\";\n    return _f;\n  }();\n\n  var isTouchEvent = function () {\n    var _f = function _f(event) {\n      return event.eventType != null;\n    };\n\n    _f._closure = {};\n    _f.asString = \"function isTouchEvent(event){return event.eventType!=null;}\";\n    _f.__workletHash = 15872269086045;\n    _f.__location = \"C:\\\\Users\\\\APIWATSRINUKUL\\\\Desktop\\\\EventLoopAPP\\\\node_modules\\\\react-native-gesture-handler\\\\lib\\\\module\\\\handlers\\\\gestures\\\\GestureDetector.js (171:2)\";\n    return _f;\n  }();\n\n  var getHandler = function () {\n    var _f = function _f(type, gesture) {\n      switch (type) {\n        case _gesture2.CALLBACK_TYPE.BEGAN:\n          return gesture.onBegin;\n\n        case _gesture2.CALLBACK_TYPE.START:\n          return gesture.onStart;\n\n        case _gesture2.CALLBACK_TYPE.UPDATE:\n          return gesture.onUpdate;\n\n        case _gesture2.CALLBACK_TYPE.CHANGE:\n          return gesture.onChange;\n\n        case _gesture2.CALLBACK_TYPE.END:\n          return gesture.onEnd;\n\n        case _gesture2.CALLBACK_TYPE.FINALIZE:\n          return gesture.onFinalize;\n\n        case _gesture2.CALLBACK_TYPE.TOUCHES_DOWN:\n          return gesture.onTouchesDown;\n\n        case _gesture2.CALLBACK_TYPE.TOUCHES_MOVE:\n          return gesture.onTouchesMove;\n\n        case _gesture2.CALLBACK_TYPE.TOUCHES_UP:\n          return gesture.onTouchesUp;\n\n        case _gesture2.CALLBACK_TYPE.TOUCHES_CANCELLED:\n          return gesture.onTouchesCancelled;\n      }\n    };\n\n    _f._closure = {\n      CALLBACK_TYPE: {\n        BEGAN: _gesture2.CALLBACK_TYPE.BEGAN,\n        START: _gesture2.CALLBACK_TYPE.START,\n        UPDATE: _gesture2.CALLBACK_TYPE.UPDATE,\n        CHANGE: _gesture2.CALLBACK_TYPE.CHANGE,\n        END: _gesture2.CALLBACK_TYPE.END,\n        FINALIZE: _gesture2.CALLBACK_TYPE.FINALIZE,\n        TOUCHES_DOWN: _gesture2.CALLBACK_TYPE.TOUCHES_DOWN,\n        TOUCHES_MOVE: _gesture2.CALLBACK_TYPE.TOUCHES_MOVE,\n        TOUCHES_UP: _gesture2.CALLBACK_TYPE.TOUCHES_UP,\n        TOUCHES_CANCELLED: _gesture2.CALLBACK_TYPE.TOUCHES_CANCELLED\n      }\n    };\n    _f.asString = \"function getHandler(type,gesture){const{CALLBACK_TYPE}=jsThis._closure;{switch(type){case CALLBACK_TYPE.BEGAN:return gesture.onBegin;case CALLBACK_TYPE.START:return gesture.onStart;case CALLBACK_TYPE.UPDATE:return gesture.onUpdate;case CALLBACK_TYPE.CHANGE:return gesture.onChange;case CALLBACK_TYPE.END:return gesture.onEnd;case CALLBACK_TYPE.FINALIZE:return gesture.onFinalize;case CALLBACK_TYPE.TOUCHES_DOWN:return gesture.onTouchesDown;case CALLBACK_TYPE.TOUCHES_MOVE:return gesture.onTouchesMove;case CALLBACK_TYPE.TOUCHES_UP:return gesture.onTouchesUp;case CALLBACK_TYPE.TOUCHES_CANCELLED:return gesture.onTouchesCancelled;}}}\";\n    _f.__workletHash = 13033906201160;\n    _f.__location = \"C:\\\\Users\\\\APIWATSRINUKUL\\\\Desktop\\\\EventLoopAPP\\\\node_modules\\\\react-native-gesture-handler\\\\lib\\\\module\\\\handlers\\\\gestures\\\\GestureDetector.js (177:2)\";\n    return _f;\n  }();\n\n  var touchEventTypeToCallbackType = function () {\n    var _f = function _f(eventType) {\n      switch (eventType) {\n        case _EventType.EventType.TOUCHES_DOWN:\n          return _gesture2.CALLBACK_TYPE.TOUCHES_DOWN;\n\n        case _EventType.EventType.TOUCHES_MOVE:\n          return _gesture2.CALLBACK_TYPE.TOUCHES_MOVE;\n\n        case _EventType.EventType.TOUCHES_UP:\n          return _gesture2.CALLBACK_TYPE.TOUCHES_UP;\n\n        case _EventType.EventType.TOUCHES_CANCELLED:\n          return _gesture2.CALLBACK_TYPE.TOUCHES_CANCELLED;\n      }\n\n      return _gesture2.CALLBACK_TYPE.UNDEFINED;\n    };\n\n    _f._closure = {\n      EventType: {\n        TOUCHES_DOWN: _EventType.EventType.TOUCHES_DOWN,\n        TOUCHES_MOVE: _EventType.EventType.TOUCHES_MOVE,\n        TOUCHES_UP: _EventType.EventType.TOUCHES_UP,\n        TOUCHES_CANCELLED: _EventType.EventType.TOUCHES_CANCELLED\n      },\n      CALLBACK_TYPE: {\n        TOUCHES_DOWN: _gesture2.CALLBACK_TYPE.TOUCHES_DOWN,\n        TOUCHES_MOVE: _gesture2.CALLBACK_TYPE.TOUCHES_MOVE,\n        TOUCHES_UP: _gesture2.CALLBACK_TYPE.TOUCHES_UP,\n        TOUCHES_CANCELLED: _gesture2.CALLBACK_TYPE.TOUCHES_CANCELLED,\n        UNDEFINED: _gesture2.CALLBACK_TYPE.UNDEFINED\n      }\n    };\n    _f.asString = \"function touchEventTypeToCallbackType(eventType){const{EventType,CALLBACK_TYPE}=jsThis._closure;{switch(eventType){case EventType.TOUCHES_DOWN:return CALLBACK_TYPE.TOUCHES_DOWN;case EventType.TOUCHES_MOVE:return CALLBACK_TYPE.TOUCHES_MOVE;case EventType.TOUCHES_UP:return CALLBACK_TYPE.TOUCHES_UP;case EventType.TOUCHES_CANCELLED:return CALLBACK_TYPE.TOUCHES_CANCELLED;}return CALLBACK_TYPE.UNDEFINED;}}\";\n    _f.__workletHash = 4665487911277;\n    _f.__location = \"C:\\\\Users\\\\APIWATSRINUKUL\\\\Desktop\\\\EventLoopAPP\\\\node_modules\\\\react-native-gesture-handler\\\\lib\\\\module\\\\handlers\\\\gestures\\\\GestureDetector.js (213:2)\";\n    return _f;\n  }();\n\n  var runWorklet = function () {\n    var _f = function _f(type, gesture, event) {\n      var handler = getHandler(type, gesture);\n\n      if (gesture.isWorklet[type]) {\n        for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          args[_key - 3] = arguments[_key];\n        }\n\n        handler === null || handler === void 0 ? void 0 : handler.apply(void 0, [event].concat(args));\n      } else if (handler) {\n        console.warn('Animated gesture callback must be a worklet');\n      }\n    };\n\n    _f._closure = {\n      getHandler: getHandler\n    };\n    _f.asString = \"function runWorklet(type,gesture,event,...args){const{getHandler}=jsThis._closure;{const handler=getHandler(type,gesture);if(gesture.isWorklet[type]){handler===null||handler===void 0?void 0:handler(event,...args);}else if(handler){console.warn('Animated gesture callback must be a worklet');}}}\";\n    _f.__workletHash = 3175729087786;\n    _f.__location = \"C:\\\\Users\\\\APIWATSRINUKUL\\\\Desktop\\\\EventLoopAPP\\\\node_modules\\\\react-native-gesture-handler\\\\lib\\\\module\\\\handlers\\\\gestures\\\\GestureDetector.js (233:2)\";\n    return _f;\n  }();\n\n  var sharedHandlersCallbacks = _reanimatedWrapper.Reanimated.useSharedValue(null);\n\n  var lastUpdateEvent = _reanimatedWrapper.Reanimated.useSharedValue([]);\n\n  var stateControllers = [];\n\n  var callback = function () {\n    var _f = function _f(event) {\n      var currentCallback = sharedHandlersCallbacks.value;\n\n      if (!currentCallback) {\n        return;\n      }\n\n      for (var i = 0; i < currentCallback.length; i++) {\n        var gesture = currentCallback[i];\n\n        if (event.handlerTag === gesture.handlerTag) {\n          if (isStateChangeEvent(event)) {\n            if (event.oldState === _State.State.UNDETERMINED && event.state === _State.State.BEGAN) {\n              runWorklet(_gesture2.CALLBACK_TYPE.BEGAN, gesture, event);\n            } else if ((event.oldState === _State.State.BEGAN || event.oldState === _State.State.UNDETERMINED) && event.state === _State.State.ACTIVE) {\n              runWorklet(_gesture2.CALLBACK_TYPE.START, gesture, event);\n              lastUpdateEvent.value[gesture.handlerTag] = undefined;\n            } else if (event.oldState !== event.state && event.state === _State.State.END) {\n              if (event.oldState === _State.State.ACTIVE) {\n                runWorklet(_gesture2.CALLBACK_TYPE.END, gesture, event, true);\n              }\n\n              runWorklet(_gesture2.CALLBACK_TYPE.FINALIZE, gesture, event, true);\n            } else if ((event.state === _State.State.FAILED || event.state === _State.State.CANCELLED) && event.state !== event.oldState) {\n              if (event.oldState === _State.State.ACTIVE) {\n                runWorklet(_gesture2.CALLBACK_TYPE.END, gesture, event, false);\n              }\n\n              runWorklet(_gesture2.CALLBACK_TYPE.FINALIZE, gesture, event, false);\n            }\n          } else if (isTouchEvent(event)) {\n            if (!stateControllers[i]) {\n              stateControllers[i] = _gestureStateManager.GestureStateManager.create(event.handlerTag);\n            }\n\n            if (event.eventType !== _EventType.EventType.UNDETERMINED) {\n              runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);\n            }\n          } else {\n            runWorklet(_gesture2.CALLBACK_TYPE.UPDATE, gesture, event);\n\n            if (gesture.onChange && gesture.changeEventCalculator) {\n              var _gesture$changeEventC;\n\n              runWorklet(_gesture2.CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === null || _gesture$changeEventC === void 0 ? void 0 : _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));\n              lastUpdateEvent.value[gesture.handlerTag] = event;\n            }\n          }\n        }\n      }\n    };\n\n    _f._closure = {\n      sharedHandlersCallbacks: sharedHandlersCallbacks,\n      isStateChangeEvent: isStateChangeEvent,\n      State: {\n        UNDETERMINED: _State.State.UNDETERMINED,\n        BEGAN: _State.State.BEGAN,\n        ACTIVE: _State.State.ACTIVE,\n        END: _State.State.END,\n        FAILED: _State.State.FAILED,\n        CANCELLED: _State.State.CANCELLED\n      },\n      runWorklet: runWorklet,\n      CALLBACK_TYPE: {\n        BEGAN: _gesture2.CALLBACK_TYPE.BEGAN,\n        START: _gesture2.CALLBACK_TYPE.START,\n        END: _gesture2.CALLBACK_TYPE.END,\n        FINALIZE: _gesture2.CALLBACK_TYPE.FINALIZE,\n        UPDATE: _gesture2.CALLBACK_TYPE.UPDATE,\n        CHANGE: _gesture2.CALLBACK_TYPE.CHANGE\n      },\n      lastUpdateEvent: lastUpdateEvent,\n      isTouchEvent: isTouchEvent,\n      stateControllers: stateControllers,\n      GestureStateManager: {\n        create: _gestureStateManager.GestureStateManager.create\n      },\n      EventType: {\n        UNDETERMINED: _EventType.EventType.UNDETERMINED\n      },\n      touchEventTypeToCallbackType: touchEventTypeToCallbackType\n    };\n    _f.asString = \"function _f(event){const{sharedHandlersCallbacks,isStateChangeEvent,State,runWorklet,CALLBACK_TYPE,lastUpdateEvent,isTouchEvent,stateControllers,GestureStateManager,EventType,touchEventTypeToCallbackType}=jsThis._closure;{const currentCallback=sharedHandlersCallbacks.value;if(!currentCallback){return;}for(let i=0;i<currentCallback.length;i++){const gesture=currentCallback[i];if(event.handlerTag===gesture.handlerTag){if(isStateChangeEvent(event)){if(event.oldState===State.UNDETERMINED&&event.state===State.BEGAN){runWorklet(CALLBACK_TYPE.BEGAN,gesture,event);}else if((event.oldState===State.BEGAN||event.oldState===State.UNDETERMINED)&&event.state===State.ACTIVE){runWorklet(CALLBACK_TYPE.START,gesture,event);lastUpdateEvent.value[gesture.handlerTag]=undefined;}else if(event.oldState!==event.state&&event.state===State.END){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,true);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,true);}else if((event.state===State.FAILED||event.state===State.CANCELLED)&&event.state!==event.oldState){if(event.oldState===State.ACTIVE){runWorklet(CALLBACK_TYPE.END,gesture,event,false);}runWorklet(CALLBACK_TYPE.FINALIZE,gesture,event,false);}}else if(isTouchEvent(event)){if(!stateControllers[i]){stateControllers[i]=GestureStateManager.create(event.handlerTag);}if(event.eventType!==EventType.UNDETERMINED){runWorklet(touchEventTypeToCallbackType(event.eventType),gesture,event,stateControllers[i]);}}else{runWorklet(CALLBACK_TYPE.UPDATE,gesture,event);if(gesture.onChange&&gesture.changeEventCalculator){var _gesture$changeEventC;runWorklet(CALLBACK_TYPE.CHANGE,gesture,(_gesture$changeEventC=gesture.changeEventCalculator)===null||_gesture$changeEventC===void 0?void 0:_gesture$changeEventC.call(gesture,event,lastUpdateEvent.value[gesture.handlerTag]));lastUpdateEvent.value[gesture.handlerTag]=event;}}}}}}\";\n    _f.__workletHash = 8983705865779;\n    _f.__location = \"C:\\\\Users\\\\APIWATSRINUKUL\\\\Desktop\\\\EventLoopAPP\\\\node_modules\\\\react-native-gesture-handler\\\\lib\\\\module\\\\handlers\\\\gestures\\\\GestureDetector.js (256:19)\";\n    return _f;\n  }();\n\n  var event = _reanimatedWrapper.Reanimated.useEvent(callback, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], needsRebuild);\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\nvar GestureDetector = function GestureDetector(props) {\n  var _gestureConfig$toGest, _gestureConfig$toGest2;\n\n  var gestureConfig = props.gesture;\n  var gesture = (_gestureConfig$toGest = gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$toGest2 = gestureConfig.toGestureArray) === null || _gestureConfig$toGest2 === void 0 ? void 0 : _gestureConfig$toGest2.call(gestureConfig)) !== null && _gestureConfig$toGest !== void 0 ? _gestureConfig$toGest : [];\n  var useAnimated = gesture.find(function (gesture) {\n    return gesture.handlers.isWorklet.reduce(function (prev, current) {\n      return prev || current;\n    });\n  }) != null;\n  var viewRef = (0, _react.useRef)(null);\n  var firstRenderRef = (0, _react.useRef)(true);\n  var webEventHandlersRef = (0, _react.useRef)({\n    onGestureHandlerEvent: function onGestureHandlerEvent(e) {\n      (0, _eventReceiver.onGestureHandlerEvent)(e.nativeEvent);\n    }\n  });\n\n  var preparedGesture = _react.default.useRef({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error('You cannot change whether you are using gesture or animatedGesture while the app is running');\n  }\n\n  var needsToRebuildReanimatedEvent = preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n\n  if (preparedGesture.firstExecution) {\n    var _gestureConfig$initia;\n\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$initia = gestureConfig.initialize) === null || _gestureConfig$initia === void 0 ? void 0 : _gestureConfig$initia.call(gestureConfig);\n  }\n\n  if (useAnimated) {\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n\n  (0, _react.useEffect)(function () {\n    firstRenderRef.current = true;\n    var viewTag = (0, _gestureHandlerCommon.findNodeHandle)(viewRef.current);\n    attachHandlers({\n      preparedGesture: preparedGesture,\n      gestureConfig: gestureConfig,\n      gesture: gesture,\n      viewTag: viewTag,\n      useAnimated: useAnimated,\n      webEventHandlersRef: webEventHandlersRef\n    });\n    return function () {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n  (0, _react.useEffect)(function () {\n    if (!firstRenderRef.current) {\n      var viewTag = (0, _gestureHandlerCommon.findNodeHandle)(viewRef.current);\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture: preparedGesture,\n          gestureConfig: gestureConfig,\n          gesture: gesture,\n          viewTag: viewTag,\n          useAnimated: useAnimated,\n          webEventHandlersRef: webEventHandlersRef\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return _react.default.createElement(AnimatedWrap, {\n      ref: viewRef,\n      onGestureHandlerEvent: preparedGesture.animatedEventHandler\n    }, props.children);\n  } else {\n    return _react.default.createElement(Wrap, {\n      ref: viewRef\n    }, props.children);\n  }\n};\n\nexports.GestureDetector = GestureDetector;\n\nvar Wrap = function (_React$Component) {\n  (0, _inherits2.default)(Wrap, _React$Component);\n\n  var _super = _createSuper(Wrap);\n\n  function Wrap() {\n    (0, _classCallCheck2.default)(this, Wrap);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Wrap, [{\n    key: \"render\",\n    value: function render() {\n      var child = _react.default.Children.only(this.props.children);\n\n      return _react.default.cloneElement(child, {\n        collapsable: false\n      }, child.props.children);\n    }\n  }]);\n  return Wrap;\n}(_react.default.Component);\n\nvar AnimatedWrap = (_Reanimated$default$c = _reanimatedWrapper.Reanimated === null || _reanimatedWrapper.Reanimated === void 0 ? void 0 : (_Reanimated$default = _reanimatedWrapper.Reanimated.default) === null || _Reanimated$default === void 0 ? void 0 : _Reanimated$default.createAnimatedComponent(Wrap)) !== null && _Reanimated$default$c !== void 0 ? _Reanimated$default$c : Wrap;","map":{"version":3,"sources":["GestureDetector.tsx"],"names":["BaseGesture","RNGestureHandlerModule","baseGestureHandlerWithMonitorProps","flingGestureHandlerProps","forceTouchGestureHandlerProps","panGestureHandlerProps","tapGestureHandlerProps","ALLOWED_PROPS","ref","handlerTag","interactionGroup","tag","dropHandlers","preparedGesture","handler","unregisterHandler","webEventHandlersRef","gestureConfig","setImmediate","filterConfig","registerHandler","requireToFail","extractValidHandlerTags","simultaneousWith","simultaneousHandlers","waitFor","Platform","gesture","g","i","event","CALLBACK_TYPE","EventType","getHandler","console","sharedHandlersCallbacks","Reanimated","lastUpdateEvent","stateControllers","callback","currentCallback","isStateChangeEvent","State","runWorklet","isTouchEvent","GestureStateManager","touchEventTypeToCallbackType","GestureDetector","props","useAnimated","prev","viewRef","useRef","firstRenderRef","onGestureHandlerEvent","e","config","animatedEventHandler","animatedHandlers","firstExecution","needsToRebuildReanimatedEvent","needsToReattach","useAnimatedGesture","useEffect","viewTag","findNodeHandle","attachHandlers","updateHandlers","React","render","child","collapsable","AnimatedWrap"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAOA;;AACA;;AACA;;AACA;;AASA;;AAIA;;AACA;;AACA;;AACA;;AAIA;;AACA;;AACA;;AAEA;;AAEA;;;;;;;;;;;;AAEA,IAAMO,aAAa,8CAAG,wDAAH,oCAEdD,yCAFc,oCAAG,yCAAH,oCAAG,qDAAH,oCAAG,qDAAH,oCAAG,uDAAH,oCAAnB,6CAAmB,EAAnB;;AAoBA,SAAA,mBAAA,CAAA,GAAA,EAAsD;EACpD,IAAI,OAAA,GAAA,KAAe,QAAnB,EAA6B;IAC3B,OAAA,GAAA;EADF,CAAA,MAEO,IAAIE,GAAG,YAAP,qBAAA,EAAgC;IACrC,OAAOA,GAAG,CAACC,UAAX;EADK,CAAA,MAEA;IAAA,IAAA,qBAAA,EAAA,YAAA;;IAGL,OAAA,CAAA,qBAAA,GAAA,CAAA,YAAA,GAAOD,GAAG,CAAV,OAAA,MAAA,IAAA,IAAA,YAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAOA,YAAAA,CAAP,UAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAkC,CAAlC,CAAA;EACD;AACF;;AAED,SAAA,uBAAA,CAAA,gBAAA,EAA6E;EAAA,IAAA,qBAAA,EAAA,sBAAA;;EAC3E,OAAA,CAAA,qBAAA,GACEE,gBADF,KAAA,IACEA,IAAAA,gBADF,KAAA,KAAA,CACEA,GADF,KAAA,CACEA,GADF,CAAA,sBAAA,GACEA,gBAAgB,CAAhBA,GAAAA,CADF,mBACEA,CADF,MAAA,IAAA,IAAA,sBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GACEA,sBAAAA,CAAAA,MAAAA,CAAoDC,UAAAA,GAAD;IAAA,OAASA,GAAG,GADjE,CACqD;EAAA,CAAnDD,CADF,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAA,EAAA;AAGD;;AAED,SAASE,YAAT,CAAsBC,eAAtB,EAA+D;EAC7D,KAAK,IAAL,OAAA,IAAsBA,eAAe,CAArC,MAAA,EAA8C;IAC5CZ,+BAAAA,CAAAA,kBAAAA,CAA0Ca,OAAO,CAAjDb,UAAAA;;IAEAc,IAAAA,mCAAAA,EAAkBD,OAAO,CAAzBC,UAAAA;EACD;AACF;;AAeD,SAAA,cAAA,OAOyB;EAAA,IAPD,eAOC,QAPD,eAOC;EAAA,IAPD,aAOC,QAPD,aAOC;EAAA,IAPD,OAOC,QAPD,OAOC;EAAA,IAPD,OAOC,QAPD,OAOC;EAAA,IAPD,WAOC,QAPD,WAOC;EAAA,IADvBC,mBACuB,QADvBA,mBACuB;;EACvB,IAAI,CAACH,eAAe,CAApB,cAAA,EAAqC;IACnCI,aAAa,KAAbA,IAAAA,IAAAA,aAAa,KAAA,KAAbA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAbA,UAAAA,EAAAA;EADF,CAAA,MAEO;IACLJ,eAAe,CAAfA,cAAAA,GAAAA,KAAAA;EAJqB;;EASvBK,YAAY,CAAC,YAAM;IACjBD,aAAa,KAAbA,IAAAA,IAAAA,aAAa,KAAA,KAAbA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAbA,OAAAA,EAAAA;EADFC,CAAY,CAAZA;;EATuB,2BAavB,OAbuB;IAcrBjB,+BAAAA,CAAAA,oBAAAA,CACEa,OAAO,CADTb,WAAAA,EAEEa,OAAO,CAFTb,UAAAA,EAGEkB,IAAAA,kCAAAA,EAAaL,OAAO,CAAR,MAAZK,EAHFlB,aAGEkB,CAHFlB;;IAMAmB,IAAAA,iCAAAA,EAAgBN,OAAO,CAAR,UAAfM,EAP6B,OAO7BA;IAIAF,YAAY,CAAC,YAAM;MACjB,IAAIG,aAAuB,GAA3B,EAAA;;MACA,IAAIP,OAAO,CAAPA,MAAAA,CAAJ,aAAA,EAAkC;QAChCO,aAAa,GAAGC,uBAAuB,CAACR,OAAO,CAAPA,MAAAA,CAAxCO,aAAuC,CAAvCA;MACD;;MAED,IAAIE,gBAA0B,GAA9B,EAAA;;MACA,IAAIT,OAAO,CAAPA,MAAAA,CAAJ,gBAAA,EAAqC;QACnCS,gBAAgB,GAAGD,uBAAuB,CACxCR,OAAO,CAAPA,MAAAA,CADFS,gBAA0C,CAA1CA;MAGD;;MAEDtB,+BAAAA,CAAAA,oBAAAA,CACEa,OAAO,CADTb,UAAAA,EAEEkB,IAAAA,kCAAAA,EAAaL,OAAO,CAAR,MAAZK,EAAY,aAAZA,EAA4C;QAC1CK,oBAAoB,EADsB,gBAAA;QAE1CC,OAAO,EAAEJ;MAFiC,CAA5CF,CAFFlB;IAbFiB,CAAY,CAAZA;EAxBqB;;EAavB,KAAK,IAAL,OAAA,IAAA,OAAA,EAA+B;IAAA,MAA/B,OAA+B;EAgC9B;;EACDL,eAAe,CAAfA,MAAAA,GAAAA,OAAAA;;EAEA,KAAK,IAAL,QAAA,IAAsBA,eAAe,CAArC,MAAA,EAA8C;IAC5C,IAAIa,qBAAAA,CAAAA,EAAAA,KAAJ,KAAA,EAA2B;MACxBzB,+BAAAA,CAAD,oBAACA,CACC0B,QAAO,CADT,UAAC1B,EAAD,OAACA,EAGC,CAHF,WAACA,EAAD,mBAACA;IADH,CAAA,MAOO;MACLA,+BAAAA,CAAAA,oBAAAA,CACE0B,QAAO,CADT1B,UAAAA,EAAAA,OAAAA,EAGE,CAHFA,WAAAA;IAKD;EACF;;EAED,IAAIY,eAAe,CAAnB,gBAAA,EAAsC;IACpCA,eAAe,CAAfA,gBAAAA,CAAAA,KAAAA,GAA0Cc,OAAO,CAAPA,GAAAA,CACvCC,UAAAA,CAAD;MAAA,OAAOA,CAAC,CADVf,QACE;IAAA,CADwCc,CAA1Cd;EAGD;AACF;;AAED,SAAA,cAAA,CAAA,eAAA,EAAA,aAAA,EAAA,OAAA,EAIE;EACAI,aAAa,KAAbA,IAAAA,IAAAA,aAAa,KAAA,KAAbA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAbA,OAAAA,EAAAA;;EAEA,KAAK,IAAIY,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGF,OAAO,CAA3B,MAAA,EAAoCE,CAApC,EAAA,EAAyC;IACvC,IAAMf,OAAO,GAAGD,eAAe,CAAfA,MAAAA,CADuB,CACvBA,CAAhB;;IAIA,IAAIc,OAAO,CAAPA,CAAO,CAAPA,CAAAA,UAAAA,KAA0Bb,OAAO,CAArC,UAAA,EAAkD;MAChDa,OAAO,CAAPA,CAAO,CAAPA,CAAAA,UAAAA,GAAwBb,OAAO,CAA/Ba,UAAAA;MACAA,OAAO,CAAPA,CAAO,CAAPA,CAAAA,QAAAA,CAAAA,UAAAA,GAAiCb,OAAO,CAAxCa,UAAAA;IACD;EAXH;;EAiBAT,YAAY,CAAC,YAAM;IACjB,KAAK,IAAIW,EAAC,GAAV,CAAA,EAAgBA,EAAC,GAAGF,OAAO,CAA3B,MAAA,EAAoCE,EAApC,EAAA,EAAyC;MACvC,IAAMf,QAAO,GAAGD,eAAe,CAAfA,MAAAA,CAAhB,EAAgBA,CAAhB;MAEAC,QAAO,CAAPA,MAAAA,GAAiBa,OAAO,CAAPA,EAAO,CAAPA,CAAjBb,MAAAA;MACAA,QAAO,CAAPA,QAAAA,GAAmBa,OAAO,CAAPA,EAAO,CAAPA,CAAnBb,QAAAA;MAEA,IAAMO,aAAa,GAAGC,uBAAuB,CAC3CR,QAAO,CAAPA,MAAAA,CADF,aAA6C,CAA7C;MAIA,IAAMS,gBAAgB,GAAGD,uBAAuB,CAC9CR,QAAO,CAAPA,MAAAA,CADF,gBAAgD,CAAhD;;MAIAb,+BAAAA,CAAAA,oBAAAA,CACEa,QAAO,CADTb,UAAAA,EAEEkB,IAAAA,kCAAAA,EAAaL,QAAO,CAAR,MAAZK,EAAY,aAAZA,EAA4C;QAC1CK,oBAAoB,EADsB,gBAAA;QAE1CC,OAAO,EAAEJ;MAFiC,CAA5CF,CAFFlB;;MAQAmB,IAAAA,iCAAAA,EAAgBN,QAAO,CAAR,UAAfM,EAAAA,QAAAA;IACD;;IAED,IAAIP,eAAe,CAAnB,gBAAA,EAAsC;MACpCA,eAAe,CAAfA,gBAAAA,CAAAA,KAAAA,GAA0CA,eAAe,CAAfA,MAAAA,CAAAA,GAAAA,CACvCe,UAAAA,CAAD;QAAA,OAAOA,CAAC,CADVf,QACE;MAAA,CADwCA,CAA1CA;IAGD;EA9BHK,CAAY,CAAZA;AAgCD;;AAED,SAAA,eAAA,CAAA,eAAA,EAAA,OAAA,EAGE;EACA,IAAIS,OAAO,CAAPA,MAAAA,KAAmBd,eAAe,CAAfA,MAAAA,CAAvB,MAAA,EAAsD;IACpD,OAAA,IAAA;EACD;;EACD,KAAK,IAAIgB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGF,OAAO,CAA3B,MAAA,EAAoCE,CAApC,EAAA,EAAyC;IACvC,IAAIF,OAAO,CAAPA,CAAO,CAAPA,CAAAA,WAAAA,KAA2Bd,eAAe,CAAfA,MAAAA,CAAAA,CAAAA,EAA/B,WAAA,EAAsE;MACpE,OAAA,IAAA;IACD;EACF;;EAED,OAAA,KAAA;AACD;;AAED,SAAA,kBAAA,CAAA,eAAA,EAAA,YAAA,EAGE;EACA,IAAI,CAAJ,6BAAA,EAAiB;IACf;EACD;;EAHD,IAKA,kBALA;IAAA,qBAKA,KALA,EAOoC;MAGlC,OAAOiB,KAAK,CAALA,QAAAA,IAAP,IAAA;IACD,CAXD;;IAAA;IAAA;IAAA;IAAA;IAAA;EAAA;;EAAA,IAaA,YAbA;IAAA,qBAaA,KAbA,EAe8B;MAE5B,OAAOA,KAAK,CAALA,SAAAA,IAAP,IAAA;IACD,CAlBD;;IAAA;IAAA;IAAA;IAAA;IAAA;EAAA;;EAAA,IAoBA,UApBA;IAAA,qBAoBA,IApBA,EAoBA,OApBA,EAuBE;MAEA,QAAA,IAAA;QACE,KAAKC,uBAAAA,CAAL,KAAA;UACE,OAAOJ,OAAO,CAAd,OAAA;;QACF,KAAKI,uBAAAA,CAAL,KAAA;UACE,OAAOJ,OAAO,CAAd,OAAA;;QACF,KAAKI,uBAAAA,CAAL,MAAA;UACE,OAAOJ,OAAO,CAAd,QAAA;;QACF,KAAKI,uBAAAA,CAAL,MAAA;UACE,OAAOJ,OAAO,CAAd,QAAA;;QACF,KAAKI,uBAAAA,CAAL,GAAA;UACE,OAAOJ,OAAO,CAAd,KAAA;;QACF,KAAKI,uBAAAA,CAAL,QAAA;UACE,OAAOJ,OAAO,CAAd,UAAA;;QACF,KAAKI,uBAAAA,CAAL,YAAA;UACE,OAAOJ,OAAO,CAAd,aAAA;;QACF,KAAKI,uBAAAA,CAAL,YAAA;UACE,OAAOJ,OAAO,CAAd,aAAA;;QACF,KAAKI,uBAAAA,CAAL,UAAA;UACE,OAAOJ,OAAO,CAAd,WAAA;;QACF,KAAKI,uBAAAA,CAAL,iBAAA;UACE,OAAOJ,OAAO,CAAd,kBAAA;MApBJ;IAsBD,CA/CD;;IAAA;MAAA;QAAA,OAvPA3B,uBAAAA,CAHF,KA0PE;QAAA,OAjPKC,uBAAAA,CAAP,KAiPE;QAAA,QAnOOE,uBAAAA,CAAT,MAmOE;QAAA,QA/NAE,uBAAAA,CADF,MAgOE;QAAA,KA1NF,uBAAA,CAAA,GA0NE;QAAA,UApNIE,uBAAAA,CACJ,QAmNA;QAAA,cA/LI,uBAAA,CAAJ,YA+LA;QAAA,cA5LE,uBAAA,CAAA,YA4LF;QAAA,Y,kCAAA;QAAA,mBAxLE,uBAAA,CAAA;MAwLF;IAAA;IAAA;IAAA;IAAA;IAAA;EAAA;;EAAA,IAiDA,4BAjDA;IAAA,qBAiDA,SAjDA,EAiD2E;MAEzE,QAAA,SAAA;QACE,KAAKyB,oBAAAA,CAAL,YAAA;UACE,OAAOD,uBAAAA,CAAP,YAAA;;QACF,KAAKC,oBAAAA,CAAL,YAAA;UACE,OAAOD,uBAAAA,CAAP,YAAA;;QACF,KAAKC,oBAAAA,CAAL,UAAA;UACE,OAAOD,uBAAAA,CAAP,UAAA;;QACF,KAAKC,oBAAAA,CAAL,iBAAA;UACE,OAAOD,uBAAAA,CAAP,iBAAA;MARJ;;MAUA,OAAOA,uBAAAA,CAAP,SAAA;IACD,CA9DD;;IAAA;MAAA;QAAA,cAvPA/B,oBAAAA,CAHF,YA0PE;QAAA,cAjPKC,oBAAAA,CAAAA,YAiPL;QAAA,YAnOOE,oBAAAA,CAAAA,UAmOP;QAAA,mBA/NAE,oBAAAA,CAAAA;MA+NA;MAAA;QAAA,cAnPF,uBAAA,CAAA,YAmPE;QAAA,cA/OAH,uBAAAA,CADF,YAgPE;QAAA,YAlOOE,uBAAAA,CAAT,UAkOE;QAAA,mBA5NOE,uBAAAA,CAAT,iBA4NE;QAAA,WAxNF,uBAAA,CAAA;MAwNE;IAAA;IAAA;IAAA;IAAA;IAAA;EAAA;;EAAA,IAgEA,UAhEA;IAAA,qBAgEA,IAhEA,EAgEA,OAhEA,EAgEA,KAhEA,EAqEE;MAEA,IAAMQ,OAAO,GAAGmB,UAAU,CAAA,IAAA,EAA1B,OAA0B,CAA1B;;MACA,IAAIN,OAAO,CAAPA,SAAAA,CAAJ,IAAIA,CAAJ,EAA6B;QAAA,kCAR/B,IAQ+B;UAR/B,IAQ+B;QAAA;;QAG3Bb,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAA,KAAPA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,MAAPA,UAAO,KAAPA,SAAAA,IAAAA,EAAAA;MAHF,CAAA,MAIO,IAAA,OAAA,EAAa;QAClBoB,OAAO,CAAPA,IAAAA,CAAAA,6CAAAA;MACD;IA9EH,CAAA;;IAAA;MAAA,YA3PF;IA2PE;IAAA;IAAA;IAAA;IAAA;EAAA;;EAoFA,IAAMC,uBAAuB,GAAGC,6BAAAA,CAAAA,cAAAA,CApFhC,IAoFgCA,CAAhC;;EAKA,IAAMC,eAAe,GAAGD,6BAAAA,CAAAA,cAAAA,CAzFxB,EAyFwBA,CAAxB;;EAKA,IAAME,gBAA2C,GAAjD,EAAA;;EAEA,IAAMC,QAAQ;IAAA,qBAAG,KAAH,EAET;MAGH,IAAMC,eAAe,GAAGL,uBAAuB,CAA/C,KAAA;;MACA,IAAI,CAAJ,eAAA,EAAsB;QACpB;MACD;;MAED,KAAK,IAAIN,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGW,eAAe,CAAnC,MAAA,EAA4CX,CAA5C,EAAA,EAAiD;QAC/C,IAAMF,OAAO,GAAGa,eAAe,CAA/B,CAA+B,CAA/B;;QAEA,IAAIV,KAAK,CAALA,UAAAA,KAAqBH,OAAO,CAAhC,UAAA,EAA6C;UAC3C,IAAIc,kBAAkB,CAAtB,KAAsB,CAAtB,EAA+B;YAC7B,IACEX,KAAK,CAALA,QAAAA,KAAmBY,YAAAA,CAAnBZ,YAAAA,IACAA,KAAK,CAALA,KAAAA,KAAgBY,YAAAA,CAFlB,KAAA,EAGE;cACAC,UAAU,CAACZ,uBAAAA,CAAD,KAAA,EAAA,OAAA,EAAVY,KAAU,CAAVA;YAJF,CAAA,MAKO,IACL,CAACb,KAAK,CAALA,QAAAA,KAAmBY,YAAAA,CAAnBZ,KAAAA,IACCA,KAAK,CAALA,QAAAA,KAAmBY,YAAAA,CADrB,YAAA,KAEAZ,KAAK,CAALA,KAAAA,KAAgBY,YAAAA,CAHX,MAAA,EAIL;cACAC,UAAU,CAACZ,uBAAAA,CAAD,KAAA,EAAA,OAAA,EAAVY,KAAU,CAAVA;cACAN,eAAe,CAAfA,KAAAA,CAAsBV,OAAO,CAA7BU,UAAAA,IAAAA,SAAAA;YANK,CAAA,MAOA,IACLP,KAAK,CAALA,QAAAA,KAAmBA,KAAK,CAAxBA,KAAAA,IACAA,KAAK,CAALA,KAAAA,KAAgBY,YAAAA,CAFX,GAAA,EAGL;cACA,IAAIZ,KAAK,CAALA,QAAAA,KAAmBY,YAAAA,CAAvB,MAAA,EAAqC;gBACnCC,UAAU,CAACZ,uBAAAA,CAAD,GAAA,EAAA,OAAA,EAAA,KAAA,EAAVY,IAAU,CAAVA;cACD;;cACDA,UAAU,CAACZ,uBAAAA,CAAD,QAAA,EAAA,OAAA,EAAA,KAAA,EAAVY,IAAU,CAAVA;YAPK,CAAA,MAQA,IACL,CAACb,KAAK,CAALA,KAAAA,KAAgBY,YAAAA,CAAhBZ,MAAAA,IAAgCA,KAAK,CAALA,KAAAA,KAAgBY,YAAAA,CAAjD,SAAA,KACAZ,KAAK,CAALA,KAAAA,KAAgBA,KAAK,CAFhB,QAAA,EAGL;cACA,IAAIA,KAAK,CAALA,QAAAA,KAAmBY,YAAAA,CAAvB,MAAA,EAAqC;gBACnCC,UAAU,CAACZ,uBAAAA,CAAD,GAAA,EAAA,OAAA,EAAA,KAAA,EAAVY,KAAU,CAAVA;cACD;;cACDA,UAAU,CAACZ,uBAAAA,CAAD,QAAA,EAAA,OAAA,EAAA,KAAA,EAAVY,KAAU,CAAVA;YACD;UA7BH,CAAA,MA8BO,IAAIC,YAAY,CAAhB,KAAgB,CAAhB,EAAyB;YAC9B,IAAI,CAACN,gBAAgB,CAArB,CAAqB,CAArB,EAA0B;cACxBA,gBAAgB,CAAhBA,CAAgB,CAAhBA,GAAsBO,wCAAAA,CAAAA,MAAAA,CAA2Bf,KAAK,CAAtDQ,UAAsBO,CAAtBP;YACD;;YAED,IAAIR,KAAK,CAALA,SAAAA,KAAoBE,oBAAAA,CAAxB,YAAA,EAAgD;cAC9CW,UAAU,CACRG,4BAA4B,CAAChB,KAAK,CAD1B,SACoB,CADpB,EAAA,OAAA,EAAA,KAAA,EAIRQ,gBAAgB,CAJlBK,CAIkB,CAJR,CAAVA;YAMD;UAZI,CAAA,MAaA;YACLA,UAAU,CAACZ,uBAAAA,CAAD,MAAA,EAAA,OAAA,EAAVY,KAAU,CAAVA;;YAEA,IAAIhB,OAAO,CAAPA,QAAAA,IAAoBA,OAAO,CAA/B,qBAAA,EAAuD;cAAA,IAAA,qBAAA;;cACrDgB,UAAU,CACRZ,uBAAAA,CADQ,MAAA,EAAA,OAAA,EAAA,CAAA,qBAAA,GAGRJ,OAAO,CAHC,qBAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAGRA,qBAAAA,CAAAA,IAAAA,CAAAA,OAAAA,EAAO,KAAPA,EAEEU,eAAe,CAAfA,KAAAA,CAAsBV,OAAO,CALjCgB,UAKIN,CAFFV,CAHQ,CAAVgB;cASAN,eAAe,CAAfA,KAAAA,CAAsBV,OAAO,CAA7BU,UAAAA,IAAAA,KAAAA;YACD;UACF;QACF;MACF;IA1KH,CAgGc;;IAAA;MAAA,yBA3VhB,uBA2VgB;MAAA,oBA/TdhC,kBA+Tc;MAAA;QAAA,cA1ThB,YAAA,CAAA,YA0TgB;QAAA,OA1ThB,YAAA,CAAA,KA0TgB;QAAA,QA3RP,YAAA,CAAA,MA2RO;QAAA,KAlTXC,YAAAA,CAFiB,GAoTN;QAAA,QA5RZ,YAAA,CAAA,MA4RY;QAAA,WA5RZ,YAAA,CAAA;MA4RY;MAAA,YAxQf,UAwQe;MAAA;QAAA,OA3ThB,uBAAA,CAAA,KA2TgB;QAAA,OAxThB,uBAAA,CAAA,KAwTgB;QAAA,KA3RP,uBAAA,CAAA,GA2RO;QAAA,UAzRZ,uBAAA,CAAA,QAyRY;QAAA,QA9QhB,uBAAA,CAAA,MA8QgB;QAAA,QAxQf,uBAAA,CAAA;MAwQe;MAAA,iB,eAAA;MAAA,cAvRb,YAuRa;MAAA,kBAnRd,gBAmRc;MAAA;QAAA,Q;MAAA;MAAA;QAAA,c;MAAA;MAAA,8BAnRd;IAmRc;IAAA;IAAA;IAAA;IAAA;EAAA,GAAd;;EA8EA,IAAMwB,KAAK,GAAGM,6BAAAA,CAAAA,QAAAA,CAAAA,QAAAA,EAEZ,CAAA,6BAAA,EAFYA,uBAEZ,CAFYA,EAAd,YAAcA,CAAd;;EAMAvB,eAAe,CAAfA,oBAAAA,GAAAA,KAAAA;EACAA,eAAe,CAAfA,gBAAAA,GAAAA,uBAAAA;AACD;;AAKM,IAAMkC,eAA8D,GACzEC,SADWD,eACXC,CAAAA,KAD4E,EAEzE;EAAA,IAAA,qBAAA,EAAA,sBAAA;;EACH,IAAM/B,aAAa,GAAG+B,KAAK,CAA3B,OAAA;EACA,IAAMrB,OAAO,GAAA,CAAA,qBAAA,GAAGV,aAAH,KAAA,IAAGA,IAAAA,aAAH,KAAA,KAAA,CAAGA,GAAH,KAAA,CAAGA,GAAH,CAAA,sBAAA,GAAGA,aAAa,CAAhB,cAAA,MAAA,IAAA,IAAA,sBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAGA,sBAAAA,CAAAA,IAAAA,CAAH,aAAGA,CAAH,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAb,EAAA;EACA,IAAMgC,WAAW,GACftB,OAAO,CAAPA,IAAAA,CAAcA,UAAAA,OAAD;IAAA,OACXA,OAAO,CAAPA,QAAAA,CAAAA,SAAAA,CAAAA,MAAAA,CAAkC,UAAA,IAAA,EAAA,OAAA;MAAA,OAAmBuB,IAAI,IAD3DvB,OACoC;IAAA,CAAlCA,CADW;EAAA,CAAbA,KADF,IAAA;EAIA,IAAMwB,OAAO,GAAGC,IAAAA,aAAAA,EAAhB,IAAgBA,CAAhB;EACA,IAAMC,cAAc,GAAGD,IAAAA,aAAAA,EAAvB,IAAuBA,CAAvB;EACA,IAAMpC,mBAAmB,GAAGoC,IAAAA,aAAAA,EAAwB;IAClDE,qBAAqB,EAAGC,+BAAAA,CAAD,EAAyC;MAC9DD,IAAAA,oCAAAA,EAAsBC,CAAC,CAAvBD,WAAAA;IACD;EAHiD,CAAxBF,CAA5B;;EAMA,IAAMvC,eAAe,GAAG,cAAA,CAAA,MAAA,CAAqC;IAC3D2C,MAAM,EADqD,OAAA;IAE3DC,oBAAoB,EAFuC,IAAA;IAG3DC,gBAAgB,EAH2C,IAAA;IAI3DC,cAAc,EAJ6C,IAAA;IAK3DV,WAAW,EAAEA;EAL8C,CAArC,EAAxB,OAAA;;EAQA,IAAIA,WAAW,KAAKpC,eAAe,CAAnC,WAAA,EAAiD;IAC/C,MAAM,IAAA,KAAA,CAAN,6FAAM,CAAN;EAxBC;;EA+BH,IAAM+C,6BAA6B,GACjC/C,eAAe,CAAfA,cAAAA,IAAkCgD,eAAe,CAAA,eAAA,EADnD,OACmD,CADnD;;EAGA,IAAIhD,eAAe,CAAnB,cAAA,EAAoC;IAAA,IAAA,qBAAA;;IAClCI,aAAa,KAAbA,IAAAA,IAAAA,aAAa,KAAA,KAAbA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,qBAAAA,GAAAA,aAAa,CAAbA,UAAAA,MAAAA,IAAAA,IAAAA,qBAAAA,KAAAA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,qBAAAA,CAAAA,IAAAA,CAAAA,aAAAA,CAAAA;EACD;;EAED,IAAA,WAAA,EAAiB;IAIf6C,kBAAkB,CAAA,eAAA,EAAlBA,6BAAkB,CAAlBA;EACD;;EAEDC,IAAAA,gBAAAA,EAAU,YAAM;IACdV,cAAc,CAAdA,OAAAA,GAAAA,IAAAA;IACA,IAAMW,OAAO,GAAGC,IAAAA,oCAAAA,EAAed,OAAO,CAAtC,OAAgBc,CAAhB;IACAC,cAAc,CAAC;MACbrD,eADa,EACbA,eADa;MAEbI,aAFa,EAEbA,aAFa;MAGbU,OAHa,EAGbA,OAHa;MAIbqC,OAJa,EAIbA,OAJa;MAKbf,WALa,EAKbA,WALa;MAMbjC,mBAAAA,EAAAA;IANa,CAAD,CAAdkD;IASA,OAAO,YAAM;MACXtD,YAAY,CAAZA,eAAY,CAAZA;IADF,CAAA;EAZO,CAATmD,EAAAA,EAAAA;EAiBAA,IAAAA,gBAAAA,EAAU,YAAM;IACd,IAAI,CAACV,cAAc,CAAnB,OAAA,EAA6B;MAC3B,IAAMW,OAAO,GAAGC,IAAAA,oCAAAA,EAAed,OAAO,CAAtC,OAAgBc,CAAhB;;MAEA,IAAIJ,eAAe,CAAA,eAAA,EAAnB,OAAmB,CAAnB,EAA+C;QAC7CjD,YAAY,CAAZA,eAAY,CAAZA;QACAsD,cAAc,CAAC;UACbrD,eADa,EACbA,eADa;UAEbI,aAFa,EAEbA,aAFa;UAGbU,OAHa,EAGbA,OAHa;UAIbqC,OAJa,EAIbA,OAJa;UAKbf,WALa,EAKbA,WALa;UAMbjC,mBAAAA,EAAAA;QANa,CAAD,CAAdkD;MAFF,CAAA,MAUO;QACLC,cAAc,CAAA,eAAA,EAAA,aAAA,EAAdA,OAAc,CAAdA;MACD;IAfH,CAAA,MAgBO;MACLd,cAAc,CAAdA,OAAAA,GAAAA,KAAAA;IACD;EAnBM,CAATU,EAoBG,CApBHA,KAoBG,CApBHA;;EAsBA,IAAA,WAAA,EAAiB;IACf,OACE,cAAA,CAAA,aAAA,CAAA,YAAA,EAAA;MACE,GAAG,EADL,OAAA;MAEE,qBAAqB,EAAElD,eAAe,CAAC4C;IAFzC,CAAA,EAGGT,KAAK,CAJV,QACE,CADF;EADF,CAAA,MAQO;IACL,OAAO,cAAA,CAAA,aAAA,CAAA,IAAA,EAAA;MAAM,GAAG,EAAEG;IAAX,CAAA,EAAqBH,KAAK,CAAjC,QAAO,CAAP;EACD;AAhGI,CAAA;;;;IAmGP,I;;;;;;;;;;;;WACEqB,kBAAS;MAMP,IAAMC,KAAU,GAAGF,cAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAoB,KAAA,KAAA,CAAvC,QAAmBA,CAAnB;;MAEA,OAAO,cAAA,CAAA,YAAA,CAAA,KAAA,EAEL;QAAEG,WAAW,EAAE;MAAf,CAFK,EAILD,KAAK,CAALA,KAAAA,CAJF,QAAO,CAAP;IAMD;;;EAfgBF,cAAAA,CAAnB,S;;AAkBA,IAAMI,YAAY,GAAA,CAAA,qBAAA,GAAA,6BAAA,KAAA,IAAA,IAAA,6BAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,CAAA,mBAAA,GAAGpC,6BAAAA,CAAH,OAAA,MAAA,IAAA,IAAA,mBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAGA,mBAAAA,CAAAA,uBAAAA,CAAH,IAAGA,CAAH,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAlB,IAAA","sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport {\n  GestureType,\n  HandlerCallbacks,\n  BaseGesture,\n  GestureRef,\n  CALLBACK_TYPE,\n} from './gesture';\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\nimport {\n  baseGestureHandlerWithMonitorProps,\n  filterConfig,\n  findNodeHandle,\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n  HandlerStateChangeEvent,\n} from '../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from './gestureStateManager';\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\nimport {\n  panGestureHandlerProps,\n  panGestureHandlerCustomNativeProps,\n} from '../PanGestureHandler';\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\nimport { State } from '../../State';\nimport { EventType } from '../../EventType';\nimport { ComposedGesture } from './gestureComposition';\nimport { Platform } from 'react-native';\nimport type RNGestureHandlerModuleWeb from '../../RNGestureHandlerModule.web';\nimport { onGestureHandlerEvent } from './eventReceiver';\n\nconst ALLOWED_PROPS = [\n  ...baseGestureHandlerWithMonitorProps,\n  ...tapGestureHandlerProps,\n  ...panGestureHandlerProps,\n  ...panGestureHandlerCustomNativeProps,\n  ...longPressGestureHandlerProps,\n  ...forceTouchGestureHandlerProps,\n  ...flingGestureHandlerProps,\n];\n\nexport type GestureConfigReference = {\n  config: GestureType[];\n  animatedEventHandler: unknown;\n  animatedHandlers: SharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  > | null;\n  firstExecution: boolean;\n  useAnimated: boolean;\n};\n\nfunction convertToHandlerTag(ref: GestureRef): number {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    // @ts-ignore in this case it should be a ref either to gesture object or\n    // a gesture handler component, in both cases handlerTag property exists\n    return ref.current?.handlerTag ?? -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\n  return (\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\n  );\n}\n\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\n  for (const handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n\n    unregisterHandler(handler.handlerTag);\n  }\n}\n\ninterface WebEventHandler {\n  onGestureHandlerEvent: (event: HandlerStateChangeEvent<unknown>) => void;\n}\n\ninterface AttachHandlersConfig {\n  preparedGesture: GestureConfigReference;\n  gestureConfig: ComposedGesture | GestureType | undefined;\n  gesture: GestureType[];\n  viewTag: number;\n  useAnimated: boolean;\n  webEventHandlersRef: React.RefObject<WebEventHandler>;\n}\n\nfunction attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesture,\n  viewTag,\n  useAnimated,\n  webEventHandlersRef,\n}: AttachHandlersConfig) {\n  if (!preparedGesture.firstExecution) {\n    gestureConfig?.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  // use setImmediate to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  setImmediate(() => {\n    gestureConfig?.prepare();\n  });\n\n  for (const handler of gesture) {\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler);\n\n    // use setImmediate to extract handlerTags, because all refs should be initialized\n    // when it's ran\n    setImmediate(() => {\n      let requireToFail: number[] = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      let simultaneousWith: number[] = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(\n          handler.config.simultaneousWith\n        );\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n    });\n  }\n  preparedGesture.config = gesture;\n\n  for (const gesture of preparedGesture.config) {\n    if (Platform.OS === 'web') {\n      (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\n        gesture.handlerTag,\n        viewTag,\n        !useAnimated, // send direct events when using animatedGesture, device events otherwise\n        webEventHandlersRef\n      );\n    } else {\n      RNGestureHandlerModule.attachGestureHandler(\n        gesture.handlerTag,\n        viewTag,\n        !useAnimated // send direct events when using animatedGesture, device events otherwise\n      );\n    }\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = (gesture.map(\n      (g) => g.handlers\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n  }\n}\n\nfunction updateHandlers(\n  preparedGesture: GestureConfigReference,\n  gestureConfig: ComposedGesture | GestureType | undefined,\n  gesture: GestureType[]\n) {\n  gestureConfig?.prepare();\n\n  for (let i = 0; i < gesture.length; i++) {\n    const handler = preparedGesture.config[i];\n\n    // only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  setImmediate(() => {\n    for (let i = 0; i < gesture.length; i++) {\n      const handler = preparedGesture.config[i];\n\n      handler.config = gesture[i].config;\n      handler.handlers = gesture[i].handlers;\n\n      const requireToFail = extractValidHandlerTags(\n        handler.config.requireToFail\n      );\n\n      const simultaneousWith = extractValidHandlerTags(\n        handler.config.simultaneousWith\n      );\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n\n      registerHandler(handler.handlerTag, handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\n        (g) => g.handlers\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n    }\n  });\n}\n\nfunction needsToReattach(\n  preparedGesture: GestureConfigReference,\n  gesture: GestureType[]\n) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (let i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(\n  preparedGesture: GestureConfigReference,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureStateChangeEvent {\n    'worklet';\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureTouchEvent {\n    'worklet';\n    return event.eventType != null;\n  }\n\n  function getHandler(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>\n  ) {\n    'worklet';\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\n    'worklet';\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>,\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n    ...args: any[]\n  ) {\n    'worklet';\n    const handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      // @ts-ignore Logic below makes sure the correct event is send to the\n      // correct handler.\n      handler?.(event, ...args);\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (\n            event.oldState === State.UNDETERMINED &&\n            event.state === State.BEGAN\n          ) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if (\n            (event.oldState === State.BEGAN ||\n              event.oldState === State.UNDETERMINED) &&\n            event.state === State.ACTIVE\n          ) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (\n            event.oldState !== event.state &&\n            event.state === State.END\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if (\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\n            event.state !== event.oldState\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(\n              touchEventTypeToCallbackType(event.eventType),\n              gesture,\n              event,\n              stateControllers[i]\n            );\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            runWorklet(\n              CALLBACK_TYPE.CHANGE,\n              gesture,\n              gesture.changeEventCalculator?.(\n                event,\n                lastUpdateEvent.value[gesture.handlerTag]\n              )\n            );\n\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\ninterface GestureDetectorProps {\n  gesture?: ComposedGesture | GestureType;\n}\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\n  props\n) => {\n  const gestureConfig = props.gesture;\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\n  const useAnimated =\n    gesture.find((gesture) =>\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\n    ) != null;\n  const viewRef = useRef(null);\n  const firstRenderRef = useRef(true);\n  const webEventHandlersRef = useRef<WebEventHandler>({\n    onGestureHandlerEvent: (e: HandlerStateChangeEvent<unknown>) => {\n      onGestureHandlerEvent(e.nativeEvent);\n    },\n  });\n\n  const preparedGesture = React.useRef<GestureConfigReference>({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated,\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error(\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\n    );\n  }\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n\n  if (preparedGesture.firstExecution) {\n    gestureConfig?.initialize?.();\n  }\n\n  if (useAnimated) {\n    // Whether animatedGesture or gesture is used shouldn't change\n    // during while an app is running\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n\n  useEffect(() => {\n    firstRenderRef.current = true;\n    const viewTag = findNodeHandle(viewRef.current) as number;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesture,\n      viewTag,\n      useAnimated,\n      webEventHandlersRef,\n    });\n\n    return () => {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!firstRenderRef.current) {\n      const viewTag = findNodeHandle(viewRef.current) as number;\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesture,\n          viewTag,\n          useAnimated,\n          webEventHandlersRef,\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return (\n      <AnimatedWrap\n        ref={viewRef}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\n  }\n};\n\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\n  render() {\n    // I don't think that fighting with types over such a simple function is worth it\n    // The only thing it does is add 'collapsable: false' to the child component\n    // to make sure it is in the native view hierarchy so the detector can find\n    // correct viewTag to attach to.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const child: any = React.Children.only(this.props.children);\n\n    return React.cloneElement(\n      child,\n      { collapsable: false },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      child.props.children\n    );\n  }\n}\n\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\n"]},"metadata":{},"sourceType":"script"}